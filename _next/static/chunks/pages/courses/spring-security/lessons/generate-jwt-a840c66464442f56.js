(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[74],{5154:function(a,b,c){(window.__NEXT_P=window.__NEXT_P||[]).push(["/courses/spring-security/lessons/generate-jwt",function(){return c(3220)}])},2018:function(d,b,a){"use strict";var e=a(5893),c=a(5927),f=a.n(c);b.Z=function(a){var c=a.href,d=a.children,b=a.target;return(0,e.jsxs)("a",{href:c,target:void 0===b?"":b,className:"text-decoration-none","data-bs-toggle":"tooltip","data-bs-title":"Read article",children:[(0,e.jsx)("i",{className:"bi bi-file-text ".concat(f().linkIcon)}),(0,e.jsx)("span",{className:f().linkText,children:d})]})}},476:function(d,b,a){"use strict";var e=a(7568),c=a(4051),f=a.n(c),g=a(5893),h=a(637),i=a(7294),j=a(1896);b.Z=function(a){var l,b=a.fileName,m=a.href,c=a.language,d=void 0===c?"java":c,n=a.children,k=(0,i.useState)(!1),o=k[0],q=k[1],p=(l=(0,e.Z)(f().mark(function a(){return f().wrap(function(a){for(;;)switch(a.prev=a.next){case 0:return a.next=2,navigator.clipboard.writeText(n);case 2:q(!0),setTimeout(function(){return q(!1)},6e3);case 4:case"end":return a.stop()}},a)})),function(){return l.apply(this,arguments)});return(0,g.jsxs)("div",{className:"border rounded fs-6 my-4",children:[b&&(0,g.jsxs)("div",{className:"p-3 bg-light border-bottom",children:[(0,g.jsx)("span",{className:"font-monospace",children:(0,g.jsx)("a",{href:m,target:"_blank",children:b})}),(0,g.jsx)("span",{className:"float-end cursor-pointer","data-bs-toggle":"tooltip","data-bs-title":"Copy code",onClick:p,children:(0,g.jsx)("i",{className:"bi-clipboard"})})]}),(0,g.jsx)("pre",{className:"m-0 px-3 pb-3",children:(0,g.jsx)("code",{className:"language-".concat(d),children:(0,g.jsx)("span",{dangerouslySetInnerHTML:{__html:h.Z.highlight(n,{language:d}).value}})})}),o&&(0,g.jsx)(j.Z,{children:"Code copied to clipboard"})]})}},9963:function(d,b,a){"use strict";a.d(b,{aC:function(){return h},k8:function(){return i},nL:function(){return g}});var e=a(5893),c=a(4046),f=a.n(c);function g(a){var b=a.children;return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)("h1",{className:"display-5 mt-2 mb-2",children:b}),(0,e.jsx)("p",{className:f().underline})]})}function h(a){var b=a.children;return(0,e.jsx)("h3",{className:"fw-light mt-5 mb-2",children:b})}function i(a){var b=a.children;return(0,e.jsx)("h4",{className:"fw-light mt-5 mb-2",children:b})}},4621:function(c,a,b){"use strict";var d=b(5893);a.Z=function(a){var c=a.src,b=a.title;return(0,d.jsxs)("div",{className:"p-3",children:[(0,d.jsx)("div",{className:"mb-3 text-secondary text-center",children:(0,d.jsx)("em",{children:b})}),(0,d.jsx)("img",{className:"img-fluid rounded border shadow",src:c,alt:b})]})}},7291:function(d,b,a){"use strict";var e=a(5893),c=a(9472),f=a.n(c);b.Z=function(a){var b=a.children;return(0,e.jsx)("mark",{className:"font-monospace border rounded p-1 ".concat(f().mark),children:b})}},6614:function(d,b,a){"use strict";var e=a(5893),c=a(3394),f=a.n(c);b.Z=function(a){var b=a.title,c=a.children;return(0,e.jsxs)("section",{className:"px-3 pt-1 my-5 ".concat(f().notes),children:[(0,e.jsxs)("h4",{className:"mb-3",children:[(0,e.jsx)("i",{className:"bi bi-info-circle me-2"}),void 0===b?"Note":b]}),c]})}},3220:function(f,b,a){"use strict";a.r(b);var g=a(5893),h=a(9963),i=a(130),j=a(7291),k=a(476),l=a(4621),m=a(6614),c=a(3274),d=a(9927),e=a(358),n=a(2018);b.default=(0,c.default)(function(b){var a=b.githubPath;return(0,g.jsxs)(g.Fragment,{children:[(0,g.jsxs)("section",{children:[(0,g.jsx)(h.nL,{children:"Generate JWT"}),(0,g.jsxs)(i.Z,{children:["Our first step is to replace the random UUID token generation with JWT. But before generating the JWT, we will add some useful configuration in the properties and get it via ",(0,g.jsx)(j.Z,{children:"@ConfigurationProperties"})," class."]}),(0,g.jsx)(k.Z,{fileName:"application.properties",href:a+"/src/main/resources/application.properties",children:"\njwt.token.base64-encoded-secret-key=/EbiawupzOqD8MlXgzlRetQfLL5vbD65jE6Q2MJF/Gg=\njwt.token.expiry-in-seconds=600\njwt.token.signing-algorithm=HS256\n"}),(0,g.jsx)(i.Z,{children:"These properties need no explanation except for the first one. JWT must be signed with a strong secret key based on the signing algorithm we choose, else the signing algorithm will throw Weak secret key error. JJWT provides a utility to generate this SecretKey for us. We can Base64 encode it to a string and store it in a secure place and not in properties as we do."})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"Generate SecretKey using JJWT utility"}),(0,g.jsx)(i.Z,{children:"I have included below test class in this chapter, and this can be used to generate Base64 encoded SecretKey, and it also assert the equality of the decoded SecretKey with the original one."}),(0,g.jsx)(k.Z,{fileName:"SecretKeyGeneratorTest.java",href:a+"/src/test/java/com/facadecode/spring/security/SecretKeyGeneratorTest.java",children:'\npublic class SecretKeyGeneratorTest {\n  private static final SignatureAlgorithm ALGORITHM = SignatureAlgorithm.HS256;\n\n  @Test\n  public void generateBase64EncodedSecretKeyString() {\n      // Generate and Base64 encode to string to store it in disk\n      SecretKey originalKey = Keys.secretKeyFor(ALGORITHM);\n      String base64EncodedKeyString = Base64.getEncoder().encodeToString(originalKey.getEncoded());\n      System.out.println("Base64 encoded secret key generated below, store it in a secure place");\n      System.out.println(base64EncodedKeyString);\n\n      // Base64 decode from string and regenerate SecretKey\n      byte[] base64DecodedKeyBytes = Base64.getDecoder().decode(base64EncodedKeyString);\n      SecretKey regeneratedKey = new SecretKeySpec(base64DecodedKeyBytes, 0, base64DecodedKeyBytes.length, ALGORITHM.getJcaName());\n\n      assert originalKey.equals(regeneratedKey);\n  }\n}\n'})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"JWT configuration properties"}),(0,g.jsxs)(i.Z,{children:["Let's create a ",(0,g.jsx)(j.Z,{children:"@ConfigurationProperties"})," class with variables corresponding to each properties we defined earlier."]}),(0,g.jsx)(k.Z,{fileName:"JWTConfig.java",href:a+"/src/main/java/com/facadecode/spring/security/config/JWTConfig.java",children:'\n@Configuration\n@ConfigurationProperties(prefix = "jwt.token")\n@Setter\npublic class JWTConfig {\n    private String base64EncodedSecretKey;\n\n    private Integer expiryInSeconds;\n\n    private String signingAlgorithm;\n}\n'}),(0,g.jsxs)(i.Z,{children:["Add a method to regenerate ",(0,g.jsx)(j.Z,{children:"SecretKey"})," object from the Base64 encoded string in the properties similar to the above test class."]}),(0,g.jsx)(k.Z,{fileName:"JWTConfig.java",href:a+"/src/main/java/com/facadecode/spring/security/config/JWTConfig.java",children:"\npublic SecretKey getSecretKey() {\n    byte[] base64DecodedKeyBytes = Base64.getDecoder().decode(base64EncodedSecretKey);\n    SecretKey secretKey = new SecretKeySpec(base64DecodedKeyBytes, 0,\n    base64DecodedKeyBytes.length, this.getSignatureAlgorithm().getJcaName());\n    return secretKey;\n}\n"}),(0,g.jsxs)(i.Z,{children:["Add another method to get signing algorithm object of type ",(0,g.jsx)(j.Z,{children:"SignatureAlgorithm"})," from the signing-algorithm properties."]}),(0,g.jsx)(k.Z,{fileName:"JWTConfig.java",href:a+"/src/main/java/com/facadecode/spring/security/config/JWTConfig.java",children:"\npublic SignatureAlgorithm getSignatureAlgorithm() {\n    return SignatureAlgorithm.valueOf(signingAlgorithm);\n}\n"}),(0,g.jsx)(i.Z,{children:"Add couple more methods to get token issue time (current time) and expiry time (issue time + expiry-in-seconds). In our case we have configured the token expiry time to be 600 seconds from the issue time."}),(0,g.jsx)(k.Z,{fileName:"JWTConfig.java",href:a+"/src/main/java/com/facadecode/spring/security/config/JWTConfig.java",children:"\npublic Date getIssueTime() {\n    return new Date(System.currentTimeMillis());\n}\n\npublic Date getExpiryTime(Date issueDate) {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(issueDate);\n    calendar.add(Calendar.SECOND, expiryInSeconds);\n    return calendar.getTime();\n}\n"})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"Generate JWT"}),(0,g.jsxs)(i.Z,{children:["Finally we will replace the random UUID token generation in ",(0,g.jsx)(j.Z,{children:"AuthenticationService"})," with the below JWT generation using ",(0,g.jsx)(j.Z,{children:"JwtBuilder"})," class provided by ",(0,g.jsx)(j.Z,{children:"Jwts"}),"."]}),(0,g.jsx)(k.Z,{fileName:"AuthenticationService.java",href:a+"/src/main/java/com/facadecode/spring/security/service/AuthenticationService.java",children:'\npublic String generateToken(String username, String password) {\n    Authentication authentication = UsernamePasswordAuthenticationToken.unauthenticated(username, password);\n    authentication = authenticationManager.authenticate(authentication);\n    \n    String accessToken = null;\n    if (authentication.isAuthenticated()) {\n        authenticationFacade.setAuthentication(authentication);\n        \n        // Generate JWT\n        accessToken = Jwts.builder()\n            .setSubject(authentication.getName())\n            .setIssuedAt(jwtConfig.getIssueTime())\n            .setExpiration(jwtConfig.getExpiryTime(jwtConfig.getIssueTime()))\n            .setId(UUID.randomUUID().toString())\n            .addClaims(\n                Collections.singletonMap("authorities", authentication.getAuthorities()\n                        .stream()\n                        .map(GrantedAuthority::getAuthority)\n                        .collect(Collectors.toList())\n                )\n            )\n            .signWith(jwtConfig.getSecretKey(), jwtConfig.getSignatureAlgorithm())\n            .compact();\n    }\n    \n    return accessToken;\n}\n'}),(0,g.jsxs)(i.Z,{children:["Here we are setting the Subject as the name of the authenticated user, which tells us whom the token is issued to. We are setting the date & time the token was issued and it's expiry time. We are assigning a random UUID to uniquely identify the token in order to prevent token replay attacks in case the token is invalidate before it's expiry time. We have added the list of authorities of the authenticated user as custom claims using ",(0,g.jsx)(j.Z,{children:"addClaim()"}),". Finally we are signing the token using the ",(0,g.jsx)(j.Z,{children:"SecretKey"})," and ",(0,g.jsx)(j.Z,{children:"SignatureAlgorithm"})," from ",(0,g.jsx)(j.Z,{children:"JwtConfig"}),"."]}),(0,g.jsx)(m.Z,{children:(0,g.jsxs)(i.Z,{children:["We have changed the variable name from ",(0,g.jsx)("em",{children:"token"})," to ",(0,g.jsx)("em",{children:"accessToken"})," in both ",(0,g.jsx)(j.Z,{children:"AuthenticationService"})," and ",(0,g.jsx)(j.Z,{children:"AuthenticationController"})," as it is no more a simple opaque token. This new variable name better reflects its purpose that it now contains both authentication and authorization information necessary enough to access the resources in our application."]})})]}),(0,g.jsxs)("section",{children:[(0,g.jsx)(h.aC,{children:"Tidy up and Test"}),(0,g.jsxs)(i.Z,{children:["We are no more required to store the token and it's expiry time in the ",(0,g.jsx)(j.Z,{children:"AppUser"})," record in the database. JWT is now self-contained to identify who the user is and what are they allowed to do in a given timeframe. Let's tidy up the code a little by removing the ",(0,g.jsx)(j.Z,{children:"updateToken()"})," in ",(0,g.jsx)(j.Z,{children:"UserService"})," and it's pre-authorize condition from ",(0,g.jsx)(j.Z,{children:"SecurityConstants"}),"."]}),(0,g.jsxs)(i.Z,{children:["Restart the application and send a POST request to ",(0,g.jsx)("u",{children:"GenerateToken"})," API and see the JWT generated like below."]}),(0,g.jsx)(l.Z,{src:"/assets/images/spring-security/lesson27-01.png",title:"JWT generated for Admin user credentials on successful authentication"}),(0,g.jsxs)(i.Z,{children:["We can now go to ",(0,g.jsx)(n.Z,{href:"https://jwt.io/",target:"_blank",children:"JWT's official page"})," to unpack the token and see what it contains. Before pasting the generated JWT, check the Checkbox having label ",(0,g.jsx)("em",{children:"secret base64 encoded"})," in ",(0,g.jsx)("em",{children:"Verify Signature"})," section, and replace the string ",(0,g.jsx)("em",{children:"your-256-bit-secret"})," in the text box with the Base64 encoded ",(0,g.jsx)(j.Z,{children:"SecretKey"})," string from the properties. Now paste the generated JWT on the left hand side to see the Header and Payload details of the token on the right hand side."]}),(0,g.jsx)(l.Z,{src:"/assets/images/spring-security/lesson27-01.png",title:"Signature verified and decoded JWT with the payload matching the Admin claims"}),(0,g.jsxs)(i.Z,{children:["We can also use JJWT library to parse the content of JWT using ",(0,g.jsx)(j.Z,{children:"JwtParserBuilder"})," from ",(0,g.jsx)(j.Z,{children:"Jwts"})," class as we will see in the next chapter while verifying the JWT."]})]})]})},(0,e.s)(d.Z,"generate-jwt"))},5927:function(a){a.exports={linkIcon:"ArticleLink_linkIcon__cf7b_",linkText:"ArticleLink_linkText__b7K5H"}},4046:function(a){a.exports={heading:"Heading_heading__aP_DN",underline:"Heading_underline__sSwtx"}},9472:function(a){a.exports={mark:"Mark_mark__8gh_T"}},3394:function(a){a.exports={notes:"Notes_notes__up3CK"}}},function(a){a.O(0,[734,428,637,274,774,888,179],function(){var b;return a(a.s=5154)}),_N_E=a.O()}])